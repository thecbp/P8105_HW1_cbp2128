---
title: "Homework 1 Code"
author: "Christian Pascual, cbp2128"
date: "2018-09-13"
output: github_document
---

# Preliminary preparation
```{r lib_imports, message = FALSE }
library(tidyverse)
library(knitr)
set.seed(1)
```

We need to plot in this homework, so we need `ggplot` from `tidyverse`. We are also generating random numbers, so we'll set a random seed.

# Problem 1

Problem 1 reviews R's data types and type coercion. We'd like to create a data frame with columns containing one of the various types in R. Thanks to vectorization, we can create other columns performing operations on the uniformly distributed numbers.

```{r p1_df }
# Extract df length for change later
desired_col_length = 10
sentence = "Pretty sure that this sentence is 10 words long"

various_types_df = tibble(
  uniform_nums = runif(desired_col_length, min = 0, max = 5),
  is_gt_2 = uniform_nums > 2,
  characters = "P8105",
  factors = factor(is_gt_2, labels = c("NOT GT2", "GT2"))
)
```

results in:

```{r p1_df_display, echo = FALSE }
kable(various_types_df)
```

## Type Coercion

Type coercion is the conversion of one type to another. There may be times where you try to perform an operation on a set of incompatible values. It makes sense to take the average of a set of numbers, but not of a collection of text.

Within our data, I would expect `mean()` to work on the uniform sample and the Boolean values since they are or can be coerced to numerical format. Programming languages will interpret `TRUE` as 1 and `FALSE` as 0, so taking the average of a set of booleans will be like averaging a collection of 1's and 0's.

Conversely, `mean()` will not work for the character vector or the factor vector they are not numerical in nature. 

```{r p1_mean_attempts, warning = FALSE }
means_df = tibble(
  # Expected to work
  uniform_mean = mean(various_types_df$uniform_nums),
  logicals_mean = mean(various_types_df$is_gt_2),
  
  # Not expected to work
  char_mean = mean(various_types_df$characters),
  factor_mean = mean(various_types_df$factors)
)
```
results in:
```{r p1_mean_attempts_df, echo = FALSE }
kable(means_df)
```

`means_df` confirms our suspicions.  `mean()` returns a meaningful result for the uniform numbers and the logical vector, but returns `NA` value for the characters and factors. 

`means_df` has R do the type coercion implicitly, but sometimes it's better to be more explicit in your code. We will use the `as.numeric()` to try to tell R directly to do the coercion.

```{r p1_explicit_coercion_1, warning = FALSE }
exp_coercion_df1 = tibble(
  coerced_logical = as.numeric(various_types_df$is_gt_2),
  coerced_character = as.numeric(various_types_df$characters),
  coerced_factor = as.numeric(various_types_df$factors)
)
```

## Implicit to explicit coercion

Explicit conversion allows us to convert the factor data into numbers whereas implicit coercion couldn't do this. This conversion makes sense if we think about the "numbering" to the factors. The factors are countable, so we can ascribe numbers to them.

R's vectorization capabilities allow us to just plug in coercion methods into each other. Thus, we can coerce even the character vector into a set of numbers, using factors as an intermediary.

```{r p1_explicit_coercion_2, warning = FALSE }
exp_coercion_df2 = tibble(
  coerced_char2fac2num = as.numeric(
    as.factor(various_types_df$characters)
    ),
  coerced_fac2char2fac = as.numeric(
    as.character(various_types_df$factors)
    )
)
```

results in:

```{r p1_explicit_coercion_2_df, echo = FALSE}
kable(exp_coercion_df2)
```

Factor coercion allow us to connect characters to numbers. However, we cannot go from factor to character to number since the character to number conversion still doesn't make any sense to R. 


# Problem 2

This problem will focus on inline code and plotting with R. We will create our own dataset below, using `rnorm()` to generate a sample of normally distributed random numbers for both `x` and `y`. Then, we will create other columns based on these random samples.

```{r p2_df }
sample_size = 1000

data = tibble(
  x = rnorm(sample_size, mean = 0, sd = 1),
  y = rnorm(sample_size, mean = 0, sd = 1),
  is_gt0 = (x + y) > 0,
  is_gt0_as_num = as.numeric(is_gt0),
  is_gt0_factor = as.factor(is_gt0_as_num)
)
```

## Data summarization

The dataframe is too large to display, but we can summarize it. The size of the dataset is `r sample_size`, the mean is `r mean(data$x)`, the median is `r median(data$x)`, and the proportion of `TRUE` in the logical vector is `r sum(data$is_gt0 == TRUE)/sample_size`.

## Data Visualizations

Using `ggplot`, we can plot out the relationship between `x` and `y`. We'd like to differentiate between points where the `x + y` is greater than 0, so we can distinguish between them using a conditional statement. The result is a rough approximation of the Pepsi logo.

```{r p2_plot_1 }
logical_plot = ggplot(data = data) +
  geom_point(mapping = aes(x = x, y = y), 
             col = ifelse(data$is_gt0, "blue", "red")
             )
```

```{r p2_plot_1_display, echo = FALSE }
logical_plot
```

The logical vector produces only two colors because there are only two options. Sometimes, it may be useful to actually see the gradient of what our values `x + y` look like, using color.

```{r p2_plot_2 }
# Creates a function to generate proper rgb values between two given colors
gradient = colorRampPalette(c('red', 'blue'))

# gradient produces 10 colors, and we divide x + y into 10 bins to fit
ggplot(data = data) +
  geom_point(mapping = aes(x = x, y = y), 
             col = gradient(10)[as.numeric(cut(data$x + data$y, breaks = 10))]
             )
```

Lastly, we can plot out the coloring by the factors. There are only 2 factors, so the resulting plot will look like the first one.

```{r p2_plot_3 }
ggplot(data = data) +
  geom_point(mapping = aes(x = x, y = y), 
             col = ifelse(data$is_gt0_factor == 1, "blue", "red")
             )
```

All of the color scales can end up looking the same since we're only looking at binary values (TRUE/FALSE, 0/1 for logical, 1/2 for factor). If we look at the gradient of values produced by `x + y`, then you'll see that the gradient forms along the diagonal due to the normal distribution of both `x` and `y`. 

```{r save_p2_plot_1, include = FALSE }
ggsave("P2_plot_1.png", plot = logical_plot)
```
