---
title: "Homework 1 Code"
author: "Christian Pascual"
date: "9/13/2018"
output: github_document
---

# Preliminary imports and preparation
```{r lib_imports }
library(tidyverse)

set.seed(1)
```

# Problem 1

Problem 1 reviews data types in R and type coercion. We'd like to create a data frame with columns containing one of the various types in R. Thanks to vectorization, we can base most of the other columns on the uniformly distributed numbers.

```{r p1_df }
# Extract df length for change later
desired_col_length = 10

various_types_df = tibble(
  uniform_nums = runif(desired_col_length, min = 0, max = 5),
  is_gt_2 = uniform_nums > 2,
  characters = character(desired_col_length),
  factors = factor(is_gt_2, labels = c("NOT GT2", "GT2"))
)
```

Type coercion is the conversion of one type to another. In cases where you attempt to do some operation, say taking the average, on a data type that is incompatible with that operation, R will try to switch the types and salvage the situation for you.

Here, I would expect `mean()` to work on the uniform sample and the boolean values because it expects numerical values. Usually, programming languages will interpret `TRUE` as 1 and `FALSE` as 0, so taking the average here will make sense.

Conversely, it will not work for the character vector or the factor vector because it doesn't make sense to average out a string or category.

```{r p1_mean_attempts }
means_df = tibble(
  # Expected to work
  uniform_mean = mean(various_types_df$uniform_nums),
  logicals_mean = mean(various_types_df$is_gt_2),
  
  # Not expected to work
  char_mean = mean(various_types_df$characters),
  factor_mean = mean(various_types_df$factors)
)

means_df
```

`means_df` confirms our suspicions.  `mean()` returns a meaningful result from the uniform numbers and the logical vector, but returns a null value for the characters and factors. 

R did the type coercion implicitly, but it's better to be more explicit in your code. We will use the `as.numeric()` to try to tell R directly to do the coercion.

```{r p1_explicit_coercion_1 }
exp_coercion_df1 = tibble(
  coerced_logical = as.numeric(various_types_df$is_gt_2),
  coerced_character = as.numeric(various_types_df$characters),
  coerced_factor = as.numeric(various_types_df$factors)
)

exp_coercion_df1
```

Explicit conversion allows us to convert the factor data into numbers where implicit coercion couldn't do this. This conversion makes sense if we think about the "numbering" to the factors. The factors are countable, so we can ascribe numbers to them.

R's vectorization capabilities allow us to just plug in coercion methods into each other. Thus, we can coerce even the character vector into a set of numbers. This will allow us to even turn the character vector into numbers.

```{r p1_explicit_coercion_2 }
exp_coercion_df2 = tibble(
  coerced_char2fac2num = as.numeric(
    as.factor(various_types_df$characters)
    ),
  coerced_fac2char2fac = as.numeric(
    as.character(various_types_df$factors)
    )
)

exp_coercion_df2
```

Factor coercion allow us to connect characters to numbers. However, we cannot go from factor to character to number since the character to number conversion still doesn't make any sense to R. 
# Problem 2

```{r p2_df }
sample_size = 1000

data = tibble(
  x = rnorm(sample_size, mean = 0, sd = 1),
  y = rnorm(sample_size, mean = 0, sd = 1),
  is_gt0 = (x + y) > 0,
  is_gt0_as_num = as.numeric(is_gt0),
  is_gt0_factor = as.factor(is_gt0_as_num)
)

data
```

The size of the dataset is `r sample_size`, the mean is `r mean(data$x)`, the median is `r median(data$x)`, and the proportion of `TRUE` in the logical vector is `r sum(data$is_gt0 == TRUE)/sample_size`.

## Data Visualizations

```{r p2_plot_1 }
ggplot(data = data) +
  geom_point(mapping = aes(x = x, y = y), 
             col = ifelse(data$is_gt0, "blue", "red")
             )
```

```{r p2_plot_2 }
gradient = colorRampPalette(c('red', 'blue'))

ggplot(data = data) +
  geom_point(mapping = aes(x = x, y = y), 
             col = gradient(10)[as.numeric(cut(data$x + data$y, breaks = 10))]
             )
```

```{r p2_plot_3 }
ggplot(data = data) +
  geom_point(mapping = aes(x = x, y = y), 
             col = ifelse(data$is_gt0_factor == 1, "blue", "red")
             )
```

All of the color scales can end up looking the same since we're only looking at binary values (TRUE/FALSE, 0/1 for logical, 1/2 for factor). If we look at the gradient of values produced by `x + y`, then you'll see that the gradient forms along the diagonal due to the normal distribution of both `x` and `y`.

### Reminders for coding in R
* meaningful variable / object names
* readable code (one command per line; adequate whitespace and indentation; etc)
* clearly-written text to explain code and results
* a lack of superfluous code (e.g. no unused variables are defined)
