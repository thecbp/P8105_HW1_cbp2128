Homework 1 Code
================
Christian Pascual
9/13/2018

Preliminary imports and preparation
===================================

``` r
library(tidyverse)
```

    ## ── Attaching packages ─────────────────────────────────────────────────────── tidyverse 1.2.1 ──

    ## ✔ ggplot2 3.0.0     ✔ purrr   0.2.5
    ## ✔ tibble  1.4.2     ✔ dplyr   0.7.6
    ## ✔ tidyr   0.8.1     ✔ stringr 1.3.1
    ## ✔ readr   1.1.1     ✔ forcats 0.3.0

    ## ── Conflicts ────────────────────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()

``` r
set.seed(1)
```

Problem 1
=========

Problem 1 reviews data types in R and type coercion. We'd like to create a data frame with columns containing one of the various types in R. Thanks to vectorization, we can base most of the other columns on the uniformly distributed numbers.

``` r
# Extract df length for change later
desired_col_length = 10

various_types_df = tibble(
  uniform_nums = runif(desired_col_length, min = 0, max = 5),
  is_gt_2 = uniform_nums > 2,
  characters = character(desired_col_length),
  factors = factor(is_gt_2, labels = c("NOT GT2", "GT2"))
)
```

Type coercion is the conversion of one type to another. In cases where you attempt to do some operation, say taking the average, on a data type that is incompatible with that operation, R will try to switch the types and salvage the situation for you.

Here, I would expect `mean()` to work on the uniform sample and the boolean values because it expects numerical values. Usually, programming languages will interpret `TRUE` as 1 and `FALSE` as 0, so taking the average here will make sense.

Conversely, it will not work for the character vector or the factor vector because it doesn't make sense to average out a string or category.

``` r
means_df = tibble(
  # Expected to work
  uniform_mean = mean(various_types_df$uniform_nums),
  logicals_mean = mean(various_types_df$is_gt_2),
  
  # Not expected to work
  char_mean = mean(various_types_df$characters),
  factor_mean = mean(various_types_df$factors)
)
```

    ## Warning in mean.default(various_types_df$characters): argument is not
    ## numeric or logical: returning NA

    ## Warning in mean.default(various_types_df$factors): argument is not numeric
    ## or logical: returning NA

``` r
means_df
```

    ## # A tibble: 1 x 4
    ##   uniform_mean logicals_mean char_mean factor_mean
    ##          <dbl>         <dbl>     <dbl>       <dbl>
    ## 1         2.76           0.6        NA          NA

`means_df` confirms our suspicions. `mean()` returns a meaningful result from the uniform numbers and the logical vector, but returns a null value for the characters and factors.

R did the type coercion implicitly, but it's better to be more explicit in your code. We will use the `as.numeric()` to try to tell R directly to do the coercion.

``` r
exp_coercion_df1 = tibble(
  coerced_logical = as.numeric(various_types_df$is_gt_2),
  coerced_character = as.numeric(various_types_df$characters),
  coerced_factor = as.numeric(various_types_df$factors)
)

exp_coercion_df1
```

    ## # A tibble: 10 x 3
    ##    coerced_logical coerced_character coerced_factor
    ##              <dbl>             <dbl>          <dbl>
    ##  1               0                NA              1
    ##  2               0                NA              1
    ##  3               1                NA              2
    ##  4               1                NA              2
    ##  5               0                NA              1
    ##  6               1                NA              2
    ##  7               1                NA              2
    ##  8               1                NA              2
    ##  9               1                NA              2
    ## 10               0                NA              1

Explicit conversion allows us to convert the factor data into numbers where implicit coercion couldn't do this. This conversion makes sense if we think about the "numbering" to the factors. The factors are countable, so we can ascribe numbers to them.

R's vectorization capabilities allow us to just plug in coercion methods into each other. Thus, we can coerce even the character vector into a set of numbers. This will allow us to even turn the character vector into numbers.

``` r
exp_coercion_df2 = tibble(
  coerced_char2fac2num = as.numeric(
    as.factor(various_types_df$characters)
    ),
  coerced_fac2char2fac = as.numeric(
    as.character(various_types_df$factors)
    )
)
```

    ## Warning in eval_tidy(xs[[i]], unique_output): NAs introduced by coercion

``` r
exp_coercion_df2
```

    ## # A tibble: 10 x 2
    ##    coerced_char2fac2num coerced_fac2char2fac
    ##                   <dbl>                <dbl>
    ##  1                    1                   NA
    ##  2                    1                   NA
    ##  3                    1                   NA
    ##  4                    1                   NA
    ##  5                    1                   NA
    ##  6                    1                   NA
    ##  7                    1                   NA
    ##  8                    1                   NA
    ##  9                    1                   NA
    ## 10                    1                   NA

Factor coercion allow us to connect characters to numbers. However, we cannot go from factor to character to number since the character to number conversion still doesn't make any sense to R. \# Problem 2

``` r
sample_size = 1000

data = tibble(
  x = rnorm(sample_size, mean = 0, sd = 1),
  y = rnorm(sample_size, mean = 0, sd = 1),
  is_gt0 = (x + y) > 0,
  is_gt0_as_num = as.numeric(is_gt0),
  is_gt_factor = as.factor(is_gt0_as_num)
)
```

The size of the dataset is 1000, the mean is -0.0106382, the median is -0.031318, and the proportion of `TRUE` in the logical vector is 0.49.

### Reminders for coding in R

-   meaningful variable / object names
-   readable code (one command per line; adequate whitespace and indentation; etc)
-   clearly-written text to explain code and results
-   a lack of superfluous code (e.g. no unused variables are defined)
